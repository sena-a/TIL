# 1. Today I Learned

## 배열

- 배열은 객체의 일종이다. 

```js
typeof []; // object
```

- 하지만 내부적으로 특별하게 취급되어 일반적인 객체와는 조금 다른 특징을 갖고 있다.

- 가장 큰 차이점은, 배열에는 각 요소간에 순서가 있다는 점이다.

- 배열 안에 들어있는 값을 요소(element) 혹은 항목(item)이라고 한다.

- 배열은 `Array` 생성자의 인스턴스이며, 배열의 프로토타입으로  `Array.prototype` 객체가 지정되어 있다.

## 1. 배열의 생성

### 1-1. 배열 리터럴(array literal)

배열을 생성하는 가장 쉬운 방법이며, [대괄호]로 둘러주며 요소가 두 개 이상이면 (,)로 구분해준다.

```js
const empty = []; // 빈배열
const number = [1, 2, 3]; // 요소가 3개인 숫자 배열
cont
const mixed = [1, 'one', {obj: 1}, null] // 다른 데이터타입 배열
```

- 예시에서 볼 수 있듯, 배열의 요소는 각기 다른 데이터 타입이 와도 상관없다.

### 1-2. Array() 생성자

`Array()` 생성자는, 주어지는 인수의 개수에 따라 다른 방식으로 배열을 생성한다. 

- 인수가 1개인 경우
    - 인수는 배열의 길이 값이 된다. 즉, 인수 값 만큼의 길이를 갖는 빈 배열을 만들어 내며, 인수가 양의 정수가 아니라면 에러가 발생된다.

    ```js
    const a = new Array(3) // [<3 empty items>]

    a.length // 3
    ```

- 인수가 2개 이상인 경우
    - 해당 인수들을 요소로 갖는 배열을 생성한다.

    ```js
    const b = new Array(1, 2) // [1, 2]

    b.length // 2 
    ````

### 1-3. Array.of

이렇게 생성자의 동장 방식이 일관적이지 않아, ES2015에 `Array.of`정적메소드가 추가되었다. 

```js
const a = Array.of(1, 2, 3)

a // [1, 2, 3]
```

때문에, 생성자로 배열을 생성하는 것은 인수가 1개일 때의 방식으로만 사용하는 것이 좋다고한다.

## 2. 요소 읽기

객체에는 프로퍼티라는 이름-값 쌍이 있었는데 배열은 요소의 이름을 따로 지정해주지 않는다. 배열의 요소에 접근할 때에는 `인덱스(index)`를 사용한다.

- 배열의 요소에는 인덱스가 부여되는데, 첫번째 요소 = 인덱스 0 부터 시작해서 차례대로 부여된다.

```js
const arr = ['a', 'b', 'c']
```

1. 1번째 요소 = 'a' = 인덱스 0 
2. 2번째 요소 = 'b' = 인덱스 1
3. 3번째 요소 = 'c' = 인덱스 2

- n번째 요소의 인덱스는 n-1이라고 생각해도 된다.

- 이 인덱스를 사용하여 배열의 요소를 불러 올 수 있다. 

```js
const arr = ['a', 'b', 'c']

// 대문자 표기법을 사용합니다.
// 배열[인덱스번호]

arr[0] // 'a'
arr[1] // 'b'
arr[2] // 'c'
```

## 3. 요소의 수정과 추가

배열은 본래 객체이기 때문에, 객체와 마찬가지로 대괄호 표기법을 이용해서 요소를 수정할 수도 있고, 없던 요소를 추가할 수도 있다.

```js
const arr = ['a', 'b', 'c']

// 요소 수정

arr[0] = 1

console.log(arr) // [1, 'b', 'c']
```

- 요소를 추가할 때는 해당 요소를 추가하고 싶은 인덱스를 지정해주면 된다. 

```js
const arr = ['a', 'b']

arr[2] = 'd'

console.log(arr) // ['a', 'b', 'd']

arr[2] = 'c'

console.log(arr) // ['a', 'b', 'c', 'd']
```

- 배열의 길이는 최종 인덱스 위치를 기준으로 정해진다.

```js
const arr = ['a', 'b']

arr[4] = 'c'

console.log(arr) // ['a', 'b', empty, empty, 'c']

arr.length // 5
```

## 4. 원본 배열을 바꾸는 메소드

### 4-1. `fill`
한꺼번에 많은 요소를 같은 값으로 바꾸는 메소드

```js
// 기본 문법

// 채울 요소: a 채울 범위: 인덱스 x 부터 인덱스 y-1 까지
array.fill(a, x, y)

// 시작 인덱스부터 끝까지를 범위로 지정할때는 y를 생략해도 된다. 범위: 인덱스 x 부터 끝까지
array.fill(a, x)

// 범위 인수 생략 시 범위는 전체로 잡히고 모든 요소가 a로 채워진다.
array.fill(a)
```
```js
const arr = [1, 2, 3, 6, 5]

arr.fill(4, 3, 4) // [1, 2, 3, 4, 5]
// 범위 3~(4-1=3) 안의 요소를 4로 바꾼다

arr.fill(4, 3) // [1, 2, 3, 4, 4]
// 인덱스 3부터 끝까지의 요소를 전부 4로 바꾼다

arr.fill(4) // [4, 4, 4, 4, 4]
// 모든 요소를 4로 바꾼다
```
- `fill`의 범위는 실제 배열의 길이 안에서만 요소를 바꿀 수 있다. 

- 배열 길이보다 더 긴 값의 인덱스를 범위 인수로 지정하면 무시된다.

```js
const arr = [1, 2, 3, 4, 5]

arr.fill(4, 5, 7) // [1, 2, 3, 4, 5]
// 실제 배열에는 인덱스 4 까지 밖에 없으므로 무시된다.
```
- `Array` 생성자와 `fill` 메소드를 함께 사용하면, 큰 배열을 만들고 값을 채워넣는 일을 쉽게 할 수 있다.

```js
const arr = new Array(100); //[<100 empty items>]

arr.fill(5) // [5, 5, 5, 5, ...]
```

### 4-2. `push`, `pop`
배열의 끝에서부터 요소를 추가/제거하는 메소드

- 추가 : `push` 
- 제거 : `pop`

```js
// push 기본 문법

array.push(item); // 요소가 추가된 후 배열의 길이를 반환값으로 삼는다.

// ex
const arr = [1, 2, 3]

arr.push(4) // 4 = [1, 2, 3, 4].length

console.log(arr) // [1, 2, 3, 4]

// 인수로 여러개가 올 수 있다. 인수의 순서 그대로 추가 된다.
arr.push(4, 5) // 5 = [1, 2, 3, 4, 5].length
```
```js
// pop 기본 문법
array.pop(); // 제거하려고 꺼낸 마지막 요소 자체를 반환 값으로 삼는다.

// ex
const arr = [1, 2, 3]

arr.pop(); // 3 (마지막 요소 = 제거하는 요소)

console.log(arr) // [1, 2]

// pop() 속에 인수를 넣어도 무시된다. 한번에 마지막 요소 하나만 제거.
const arr = [1, 2, 3]

arr.pop(2) // 3 (인수 2 무시)

// 배열에 요소가 남아있지 않으면 undefined 를 반환한다.
```

### 4-3. `unshift`, `shift`
배열의 맨 앞에서부터 요소를 추가/제거하는 메소드

- `push` & `pop`과 전부 똑같으며, 맨 앞에서부터 추가/제거한다는 점만 다르다.
- 추가 : `unshift`
- 제거 : `shift`

```js
// unshift 기본 문법

array.unshift(item); // 요소가 추가된 후 배열의 길이를 반환값으로 삼는다.

// ex
const arr = [1, 2, 3]

arr.unshift(4) // 4 = [4, 1, 2, 3].length

console.log(arr) // [4, 1, 2, 3]

// 인수로 여러개가 올 수 있다. 인수의 순서 그대로 추가 된다.
arr.unshift(4, 5) // 5 = [4, 5, 1, 2, 3].length
```
```js
// shift 기본 문법
array.shift(); // 제거하려고 꺼낸 맨 앞의 요소 자체를 를 반환 값으로 삼는다.

// ex
const arr = [1, 2, 3]

arr.shift(); // 1 (맨 앞 요소 = 제거하는 요소)

console.log(arr) // [2, 3]

// pop() 속에 인수를 넣어도 무시된다. 한번에 마지막 요소 하나만 제거.
const arr = [1, 2, 3]

arr.shift(2) // 1 (인수 2 무시)

// 배열에 요소가 남아있지 않으면 undefined 를 반환한다.
```
### 4-4. `splice`
배열의 원하는 곳에 요소를 추가/제거하는 메소드.

```js
// 기본 문법

array.splice(x, y, items)
// 인덱스 x 부터 y개의 요소를 items로 체인지.
// 선택한 범위의 기존 요소를 가진 배열을 반환값으로 삼음
```
```js
// 요소 추가
const arr = [1, 2, 5, 6, 7]

arr.splice(2, 3, 3, 4, 5) // [5, 6, 7](인덱스 2부터 3개 요소 -> 5,6,7 을 가진 배열)
// 인덱스 2 부터 3개의 요소를 3, 4, 5로 체인지.
arr // [1, 2, 3, 4, 5]
// 꼭 같은 개수의 요소로 바꿔줄 필요는 없다

arr.splice(2, 3, 3) //[5, 6, 7]
// 인덱스 2부터 3개 요소를 3으로 체인지
arr // [1, 2, 3]
```

```js
// 요소 제거
// items 인수를 생략한다.
// 범위 안의 요소를 아무것도 없음과 체인지 = 제거
array.splice(x, y)
// 인덱스 x부터 y개 요소를 없음과 체인지
// 인덱스 x부터 y개 요소를 제거

// ex
const arr = [1, 2, 3]

arr.splice(2, 1) // [3]

arr // [1, 2]

// 해당 인덱스부터 끝까지를 범위로 삼고싶다면 갯수를 설정하는 인수도 없어도 된다.

array.splice(x)
// 인덱스 x부터 끝까지 요소를 제거
const arr = [1, 2, 3]

arr.splice(1) // [2, 3]

arr // [1] 
```

```js
// 바뀌는 요소 없이 기존 배열의 원하는 위치에 새로운 요소 추가하기
// 기본 문법
// 갯수 인수를 0으로 지정한다.
array.splice(x, 0, items) // [] (0개를 선택하였으니 선택된 요소 없이 빈배열이 반환된다)
// 인덱스 x의 바로 앞자리에 items가 추가된다.

// ex

const arr = [1, 4]

arr.splice(1, 0, 2, 3) // []

arr // [1, 2, 3, 4]
// 인덱스 1(두번째 요소) 앞자리에 items -> 2, 3이 추가됐다.
```

### 4-5. `reverse`
배열 순서를 뒤집는 메소드

```js
const arr = [1, 2, 3]

arr. reverse(); // [3, 2, 1](뒤집고 난 배열을 반환값으로 삼는다)

console.log(arr) // [3, 2, 1]
```

### 4-6. `sort`
원하는 기준으로 배열을 정렬하는 메소드

- `sort` 메소드의 인수에는 비교 함수를 반드시 넘겨주어야 한다. 결과값으로 `number타입` 값이 나오는 비교 함수여야 한다.

- 요소의 어떤 속성을 기준을 잡을지 먼저 정한 후, 해당 값을 비교하여 오름차순/내림차순으로 정렬하는 용도로 사용된다.

```js
// 기본 문법
array.sort((x, y) => 비교 함수); // 반환값 : 정렬된 배열

// x,y 에는 요소가 순서대로 들어온다.
array[0], array[1]
array[1], array[2]
...
```
- 개인적으로 이렇게 외었다.

```js
// 결과 값 : 정렬 모습
음수 : 왼쪽 요소를 앞에 정렬
양수 : 오른쪽 요소를 앞에 정렬
0 : 순서대로 정렬
// 음왼양오
```
```js
// 오름차순 정렬
// 기본 비교 함수
a = 비교 기준 x
b = 비교 기준 y
array.sort(function(x,y){
    if(a < b){
        return -1 // 왼쪽을 앞에 정렬 -> a,b -> 큰 값이 뒤에 정렬 됐다.
    }
    if(a > b){
        return 1 // 오른쪽을 앞에 정렬 b,a -> 큰값이 뒤에 정렬 됐다.
    }
    return 0 // 순서대로 정렬 a, b 
})

// 숫자
array.sort((x, y) => x - y)
// 숫자는 결과값이 바로 숫자로 나오기 때문에 굳이 if문으로 결과값을 지정해주지 않아도 된다.
// 원리는 똑같다.

// 내림차순 정렬
// 기본 비교 함수
array.sort(function(x,y){
    if(a < b){
        return 1 // 오른쪽을 앞에 정렬 -> b, a -> 큰 값이 앞에 정렬 되었다.
    }
    if(a > b){
        return -1 // 왼쪽을 앞에 정렬 -> a, b -> 큰 값이 앞에 정렬 되었다.
    }
    return 0 // 순서대로 정렬 a, b
})

// 숫자
array.sort((x, y) => y - x)
```
- 기본 비교 함수의 `return`값에 -1, 1을 사용한건 그냥 기본이라서이다. 음수값 & 양수값으로 지정해준다면 어떤 값이 와도 상관 없다.

- `sort` 메소드에 비교함수를 인수로 주지 않으면, 요소는 전부! 문자열로 변환된 뒤, `유니코드 코드포인트`를 비교하여 `오름차순`으로 정렬 된다.(숫자 역시 마찬가지니 주의할 것)

```js
const arr = ['B', 'a', 'c', 'D']

arr.sort() // ['B', 'D', 'a', 'c']
// 비교함수를 인수값으로 지정하지 않았을 때
// 대문자가 소문자보다 유니코드포인트가 작으므로 유니코드포인트의 오름차순을 정렬되었다.

// 이를 사전순으로 비교 하고 싶다면
// 문자열 사전순 비교 메소드인 .localeCompare를 사용한다. 
// 단, 이경우 오름차순 밖에 안된다.
arr.sort((x,y) => x.localeCompare(y)) //['a', 'B', 'c', 'D']

// 문자열 사전순 내림차순으로 정렬하고 싶다면 비교함수를 직접 정의한다.
arr.sort(function (x, y){
  if(x.toUpperCase() < y.toUpperCase()){
    return 1 // 오른쪽이 앞에 정렬 -> 큰 값이 앞에 정렬됨 -> 내림차순
  }
  if(x.toLocaleUpperCase() > y.toLocaleUpperCase()){
    return -1
  }
  return 0
}) // ['D', 'c', 'B', 'a']
```

### 4-7. `length`

배열의 길이를 확인하기, 늘리고, 줄이는 메소드

- 확인하기
```js
const arr = []
arr.length // 0
```

- 늘리기
```js
const arr = []
arr.length = 5 // 원하는 길이 지정(원본배열 길이보다 커야함)

arr // [<5 empty items>]
```

- 줄이기

```js
const arr = [1, 2, 3, 4, 5] // length = 5
arr.length = 3

arr // [1, 2, 3] 해당 길이만큼 줄어들고 뒤에 있는 요소들은 버려진다. 
```

`length` 메소드로 배열의 길이를 늘리고 줄일 수는 있지만, 권장되는 방법이 아니다.

---

<!-- ## 5. 새로운 값을 생성하는 메소드

- 아래의 메소드들은 새로운 값을 생성하고 원본 배열에 아무런 영향을 미치지 않는다. 

### 5-1. `slice`

### 5-2. `map`

### 5-3. `concat`

### 5-4. `reduce`

### 5-5. `filter`

### 5-6. `join`

---

## 6. 배열 순회하기

### 6-1. `for` 구문

### 6-2. `forEach` 메소드

### 6-3. `for...of` 구문

---

## 7. 다른 메소드들

### 7-1. 요소 찾기

### 7-2. 특정 조건을 만족하는지 판별

### 7-3. 배열인지 아닌지 판별

---

## 8. 다차원 배열 (Multidimensional Array)

--- -->

# 2. Today I Found Out

```
2018.10.04

메소드가 너무 많아서 이해하면서 외우기도 힘든데 다 외워도 코드에 응용하려고하면 내가 배운게 뭔가 싶다. 언젠간 술술 나오길!
```

# 3. reference
- https://helloworldjavascript.net/pages/190-array.html

- sort 메소드 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
