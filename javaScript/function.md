# 1. Today I Learned

## function(함수)

- 프로그래밍에서의 함수란, 큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용할 수 있도록 묶어놓은 코드 뭉치의 단위를 말한다. 

- 함수를 어떻게 작성하느냐에 따라서 코드의 유지보수성과 가독성이 매우매우 크게 달라진다.

- 오늘의 TIL에서는 함수의 기본적인 성질만 정리할 것이다.

---

### 1. 함수의 구성요소와 용어

- 함수의 이름
    - 한 코드 뭉치에 붙인 이름이다.
    
    ```js
    function add(x, y)

    // 함수 이름 - add
    ```

- 함수 호출(function call)
    - 함수를 정의했을 때, 함수의 매개변수 자리에 인수를 지정하여 함수를 실행시키는 행위를 함수의 호출이라고 한다.


- 매개변수(parameter)
    - 매개변수는 변수의 일종으로, 함수 호출 시마다 인수가 매개변수에 대입된다.
   
    ```js
    function add(x, y)

    // 매개변수 - x & y 
    ```

    - 매개변수는 바깥에서 선언된 변수와는 관계없는 독립적인 변수이다.

    ```js
    function reassign(x) {
    x = 2;
    return x;
    }

    const y = 1;
    const result = reassign(y);

    console.log(y); // 1

    console.log(result); // 2
    ```
    - 위 예시처럼 함수를 호출할 때 변수를 써준다고해도 변수에 저장된 값이 넘어가는 것이지 변수 자체가 넘어가는 것이 아니며, 실제 변수 y의 값이 변경되는 것이 아니므로 변수 y의 값은 함수 내부에서 재대입 되었을 지라도 여전히 1이다.

- 인수(argument)
    - 매개변수 자리에 지정해준 대입될 값을 말한다.

    ```js
    function add(x, y) {
    const result = x + y;
    return result;
    }

    add(2, 3); // 5
    ```
    - 여기서 괄호 안에 넘겨준 `2`,`3`을 인수라고 부른다

- 반환값
    - `return` 키워드 바로 다음에 오는 값이다. 

    - 반환값이 함수 호출의 결과값으로 반환되며, 값이 봔환되는 즉시 함수 실행이 끝난다.

    - 때문에, `return`코드가 실행된 시점에서 `return`코드의 뒤에 있는 코드들은 전부 실행되지 않고 함수의 실행이 종료된다.
 
    ```js
    function add(x, y) {
    return x + y;
    console.log('이 부분은 실행되지 않습니다.');
    }
    add(1, 2); // 3

    // 3 외에 따로 출력되는 내용이 없습니다.
    ```

    - JavaScript에서는 함수는 항상 값을 반환하는데, 만약 함수 내부에 `return` 뒤에 아무 값도 써주지 않거나 `return` 구문을 자체를 쓰지 않으면 함수는 `undefiend`를 반환한다.

- 실행 순서
    - JavaScript는 기본적으로 코드가 작성된 순서대로 실행되지만, 여러가지 예외 경우에서 실행 순서가 이리저리 옮겨다니기도 한다.

    - 함수 호출도 그 중 하나로, 함수 호출 코드를 만나면 코드의 실행 흐름이 호출된 함수의 내부로 옮겨간다.

    - 함수가 값을 반환하면 다시 이전 위치부터 코드의 실행이 재개된다.

    ```js
    // 1 - 함수 정의 

    function add(x, y) {
    return x + y; // 3 - 함수 실행
    }

    // 2 - 함수 호출

    const result = add(2, 3);

    // 4 - 나머지 코드 실행

    console.log(result);
    ```
    - 1. 함수가 정의가 됐구나하고 함수를 건너뛴 후 다음 코드를 본다.

    - 2. 다음 코드에서 함수가 호출됐으니, 일단 실행을 일시정지한 상태에서 인자들을 데리고 함수 반환값을 보기위해 함수 내부로 흐름이 옮겨간다
    
    - 3. 함수를 실행하여 반환할 값을 받는다.

    - 4. 반환값을 받았으니 다시 일시정지했던 위치로 돌아와 코드를 이어간다.

    - 5. 나머지 코드를 다시 정상적인 흐름으로 이어간다.

    - 유의할 점은, 함수를 정의하는 것만으로는 함수 내부의 코드가 실행되지 않으니, 함수 내부 코드를 실행하려면 반드시 함수를 호출해주어야 한다는 것이다.

---

### 2. 스코프 (Scope)

- 함수의 매개변수를 비롯한 모든 변수들을 특별한 성질을 갖는다. 

- 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있다는 것이고, 이를 변수의 `유효 범위`라고 하며, 이 유효 범위를 `스코프`라고 부른다.

- 매개변수는 함수의 내부 코드 안에서만 유효하며 이는, 매개변수는 **함수 스코프**를 갖는다는 의미이다.

```js
function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
}
add(2, 3);
console.log(x); // 에러!
```
위 코드에서, 함수의 매개변수로 정의된 x와 y의 유효범위는 아래와 같다.

```js
{ return x + y;
}
```
때문에, 함수 밖의 코드인 `console.log(x);` 속의 x는 매개변수 x와는 전혀 상관이 없는 별개의 존재이며, 함수 밖 코드에서 x 변수가 정의된 적이 없기 때문에 에러가 발생된다.

#### 2-1. 스코프 연쇄(Scope Chain)

1. 코드의 실행 흐름이 변수 이름에 도달하면, 먼저 변수를 현재 스코프에서 찾아보고, 변수가 존재하면 그것을 그대로 사용합니다. 

2. 만약 현재 스코프에서 변수를 찾지 못하면 바로 바깥쪽 스코프에서 변수를 찾아봅니다. 있으면 사용하고 없으면 바깥쪽 스코프로 올라가서 다시 찾아보는, 이 과정이 되풀이됩니다. 

3. 이 찾아보는 과정을 스코프 연쇄(scope chain)라 하고, 이 과정은 가장 바깥쪽에 있는 스코프를 만날 때까지 반복됩니다. 

4. 가장 바깥쪽 스코프까지 찾아봤는데도 같은 이름의 변수를 찾지 못하면, 그제서야 에러가 발생됩니다.

- 이 말은 즉, 큰 스코프 안에 들어있는 스코프에서는 바깥 스코프의 변수를 가져다 쓸 수 있다는 뜻이다. 

- 몇단계가 중첩 되어있건 상관없이 안쪽 스코프는 바깥쪽 스코프의 변수를 사용할 수 있는데, 이때 바깥쪽이라는 건 현재 스코프를 둘러싸고 있는 상위 스코프들을 뜻하고, 같은 레벨의 스코프와 그 하위 스코프는 해당되지 않는다.


- 가장 바깥에 있는 스코프를 **최상위 스코프(top-level scope)** 혹은 **전역 스코프(global scope)**라고 부른다.

#### 2-2. 변수 가리기(Variable Shadowing)

- 바깥쪽 스코프에 존재하는 변수와 같은 이름을 같는 변수를 안쪽 스코프에서 따로 정의할 수 있는데, 그렇게 되면 안쪽 스코프에서는 바깥쪽 스코프에 있는 이름이 무시된다. 이런 현상을 변수 가리기(variable shadowing)라고 한다.

```js
const x = 3;

function add5(x) { // `x`라는 변수가 다시 정의됨
  function add(x, y) { // `x`라는 변수가 다시 정의됨
    return x + y;
  }
  return add(x, 5);
}

add5(x);
```

- 이 매개변수는 위 쪽 스코프의 변수에 전혀 영향을 주지 않는다.

#### 2-3. 어휘적 스코핑 (Lexical Scoping)

스코프는 코드가 작성된 구조에 의해서 결정되는 것이지, 함수 호출의 형태에 의해 결정되는 것이 아니다.

#### 2-4. 스코프의 종류

스코프에는 함수 스코프만 있는 것이아니고, 다양한 스코프의 종류가 있다.

---

### 3. 값으로서의 함수

JavaScript에서는 함수도 값이다!

즉, 다른 값과 마찬가지로, 함수를 선언한 뒤 변수에 대입해서 호출할 수도 있고, 혹은 배열이나 객체에 넣을 수도 있고, 심지어는 함수를 다른 함수에 인수로 넘기거나, 함수에서 함수를 반환할 수도 있다.

```js
// 함수를 배열이나 객체에 넣기
function add(x, y) {
  return x + y;
}
[add];
{addFunc: add};

// 함수를 인수로 넘기기
function isEven(x) {
  return x % 2 === 0;
}
[1, 2, 3, 4, 5].filter(isEven); // [2, 4]

// 함수에서 함수 반환하기
function createEmptyFunc() {
  function func() {}
  return func;
```

컴퓨터 과학 분야에서 사용되는 용어 중에 1급 시민(First-Class Citizen)이라는 특이한 용어가 있다.
값으로 사용할 수 있는 JavaScript의 함수는 1급 시민이다. 1급 시민인 함수를 줄여서 1급 함수라 부르기도 한다.

---

### 4. 익명 함수 (Anonymous Function)

- JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아닏. 

- 이름을 붙이지 않은 함수를 가지고 익명 함수(anonymous function), 혹은 함수 리터럴(function literal)이라고 한다.

```js
// 두 수를 더해서 반환하는 익명 함수
function(x, y) {
  return x + y;
}
```
익명 함수는 이름이 없기 때문에 만들어지고 땡이므로, 이 함수를 사용하려면 변수에 대입해주어야 한다. 

```js
// 호출을 하려면 변수에 저장한 후에 변수의 이름을 통해 호출해야함.
const add = function(x, y) {
  return x + y;
}
add(1, 2); // 3
```

- 익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할 때 많이 사용되는데, 대표적으로 함수를 인수로 넘겨줄 때이다.

- 그냥 함수보다 익명 함수를 더 많이 쓸 수도 있을 정도로 익명 함수는 많이 사용된다.

---

### 5. 화살표 함수 (Arrow Function)

함수 정의를 위한 새로운 표기법인 화살표 함수(arrow function)은 ES2015에서 도입되었다.

```js
// 여기에서 x + y 는 바로 반환된다.
const add = (x, y) => x + y;
```

- 본래 function 키워드 함수는 리턴 키워드를 설정해줘야하는데, 화살표 함수에서는 화살표가 리턴 키워드를 대신해주기 때문에 매우 간단하다. 단, 이경우는 {...} 중괄호로 둘러싸지 않은 간단한 구문의 경우이다.

```js
// 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces({...}) 로 둘러싸주어야 한다.
// `=>` 다음 부분을 중괄호로 둘러싸면, 명시적으로 `return` 하지 않는 한 아무것도 반환되지 않는다.

const add = (x, y) => {
  const result = x + y;
  return result;
}
```

- 매개변수가 하나밖에 없다면, 매개변수 부분의 괄호조차도 생략할 수 있다.
```js
const negate = x => !x;
```

화살표 함수는 표기법이 간단하기 때문에 익명 함수를 다른 함수의 인수로 넘길 때 주로 사용된다.
```js
[1, 2, 3, 4, 5].filter(x => x % 2 === 0);

// x => x % 2 === 0는, 

function(x){
    return x % 2 === 0;
} // 과 같은 의미.
```

# 2. Today I Found Out

```
2018.10.01
```

# 3. reference

- https://helloworldjavascript.net/pages/170-function.html